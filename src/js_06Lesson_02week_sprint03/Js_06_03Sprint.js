// лексическое окружение / замыкание / рекурсия

// globalLE {} -> null
// {} создается некий глобальный объект, куда помещаются все наши переменные объявленные вне функций

//Примерно так выглядит под капотом этот объект. На момент старта скрипта. Создается globalLE {} -> null
// const globalLexicalEnvironment = {
//     environmentVariable: {
//         // сюда записываются все наши переменные
// все Function располагаются вверху. В js есть такая особенность, Все переменные объявленные при помощи function declaration принадлежат HOISTING(у), и принадлежат к всплытию
// HOISTING(у) принадлежат все функции объявленные через function declaration и все переменные объявленные при помощи var
// все переменные ниже
//     },
//     outer: null // это свойство - ссылка на внешнее глобальное окружение. Т.к. этот объект и наше глобальное окружение, то эта ссылка будет иметь значение null. Это нужно ЗАПОМНИТЬ
// }

// Технически ЛО представляет собой объект с двумя свойствами:
// запись окружения (именно тут хранятся все объявления),
// ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).
// Это служебный объект, и получить к нему доступ напрямую мы никак не можем.
// Глобальное лексическое окружение хранит объявление переменных и функций, которые были созданы в глобальном контексте выполнения.
// Ссылка же на внешнее ЛО у него равна null (потому что нет ничего «более глобального»).



//startEngine() // если мы вызовем здесь нашу функцию,  её определения, то не будет ошибки обращения к этой функции. Т.к. она уже есть в нашем globalLE { startEngine: Function }
//startEngine2() // вызов этой функции до её определения вызрвет у нас ошибку. Т.к. её еще нет в нашем globalLE { }

console.log(car2) // будет undefined, т.к. она уже есть в нашем globalLE { }, но её значение еще не определено. Есть, потому что она пренадлежит всплытию. Ошибки не будет и код пойдет работать дальше
let car = "bmw"; // на этой строке создается в globalLE { car: "bmw" } -> null
var car2 = "kia"


function startEngine() { // на этой строке создается в globalLE { startEngine: Function, car: "bmw" } -> null , Function - просто ссылка на функцию, мы пока не знаем на какую и что там. Это просто ссылка
    console.log(`Start ${car}`);
}

const startEngine2 = function() { // щбъявили функцию через выражение, а не  через FDeclaration, // на этой строке создается в globalLE { startEngine: Function, car: "bmw", startEngine2: Function }
    console.log(`Start ${car}`);
}

startEngine2() // и только сейчас мы можем к ней обратиться и вызвать её


startEngine() // Если в этом месте мы вызываем нашу функцию, то актуальным значением для car  уже будет "bmv", т.к. мы еще не перезатерли его значение

car = "audi";  // на этой строке мы ключ car перезатираем  значением "audi" , и тут оно уже становится "audi" в globalLE { startEngine: Function, car: "audi" } -> null

startEngine() // когда в этом месте мы вызываем нашу функцию, то актуальным значением для car  уже будет "audi", а не "bmv"



//---------------------------------------------------------------------------------------------------//
// все функции создают в момент их запуска свой локальный объект
function startEngine3() { // на этой строке создается в globalLE { startEngine: Function, car: "bmw" } -> null , Function - просто ссылка на функцию, мы пока не знаем на какую и что там. Это просто ссылка
    // outer: globalLE { } - ссылка на внешний глобальный объект, откуда функция может брать знчаения, если не нашла их в своем локальном объекте, созданном каждый раз при ее вызове
    // startEngine { } - локальный объект, создается каждый раз при ее вызове. Первоначально функция ищет усебя данные, а затем, если их нет, то через ссылку outer: globalLE { } ищет в глобальном объекте
    // car = "kia"
    console.log(`Start ${car}`);
}

startEngine3()
car = "REVGOT"
startEngine3()

//---------------------------------------------------------------------------------------------------//

const a = 10; // gLE { foo: Function, foo2: Function, a: 10} -> null
const b = 20; // gLE { foo: Function, foo2: Function, a: 10, b: 20} -> null
const c = 50; // gLE { foo: Function, foo2: Function, a: 10, b: 20, c: 50} -> null

function foo () {
    // fooLE {a: 30, b: 40} -> gLE {}
    const a = 30;
    const b = 40;
    console.log(a);
    foo2();
    const bar = () => {
        // barLE {} -> fooLE
        console.log(c);
    };
    bar();
}

foo()

function foo2 () {
    // foo2LE {} -> gLE {}
    console.log(b);


}

//------------------------------------------замыкание--------------------------------------------//

let count = 0;

const counterCreator = () => {
    // gLE {} -> null
    // counterCreatorLE {} -> gLE
    //let count = 0;

    return () => {
        // {} -> counterCreatorLE
        //let count = 0;
        console.log(++count);
    };
};

const counter = counterCreator();
const counter2 = counterCreator();

counter();
counter();
counter();

counter2();
counter2();
counter2();

//------------------------------------------рекурсия--------------------------------------------//

// ПРИМЕР рекурсии для возведения 2 в степень 4
// (2,4) -> 2 * 2(3) -> 2 * 2 * 2(2) -> 2 * 2 * 2 * 2
function pow(x, n) {
    if (n === 1) { // условие выхода из рекурсии
        return x;
    } else {
        return x * pow(x, n-1); // указываем, что нам нужно сделать каждый раз, но при этом шаг рекурсии предусмотреть n-1
    }
}

console.log(pow(2,4)); // 16

// ПРИМЕР рекурсии вычисления Факториала
// faq(6) -> 1 * 2 * 3 * 4 * 5 * 6 // Факториал — это произведение всех натуральных чисел от 1 до данного числа. Например, факториал числа 5 будет равен 1 × 2 × 3 × 4 × 5 = 120. Его используют во многих областях науки — например, комбинаторике, теории вероятностей и математическом анализе.

function faq(x) {
    if (x === 1) { // условие выхода из рекурсии
        return x;
    } else {
        return x * faq(x - 1); // указываем, что нам нужно сделать каждый раз, но при этом шаг рекурсии предусмотреть n-1
    }
}

console.log(faq(6));

// ПРИМЕР рекурсии Последовательность Фибоначчи
// fib(6) => 0 1 1 2 3 5 8 13
// fib(6) -> 0 + 1 + 1 + 2 + 3 + 5// Последовательность Фибоначчи — это бесконечный ряд чисел, каждый последующий член которого равен сумме двух предыдущих: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 и т.д.

function fib(x) {
    if (x <= 1) {
        return x;
    }
    return fib(x-1) + fib(x-2);
}

console.log(fib(6));