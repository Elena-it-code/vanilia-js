
// Типизируем наш объект Users
export type UsersType ={
    [key: string]: {id:number, name: string} // он имеет какйо-то ключ ('101', '326465', '8988',  ) и объект такого типа {id: 101, name: 'Ivan'}
}
//-----------------------------------Ассоциативный массив-----------------------------------------------------//
const users :UsersType = {
    '101': {id: 101, name: 'Ivan'},
    '326465': {id: 326465, name: 'Lena'},
    '586': {id: 586, name: 'Saha'},
    '8988': {id: 8988, name: 'Dima'},
    '1': {id: 1, name: 'Xenia'},
}
// ---Доставание элемента из ассоциативного массива---:
//users[1] // доставание элмента. чаще всего по id. Такой вариант считается моментальным и быстрым. О(1)

// ---Добавление нового пользователя. Присвоение нового значения---:
// К примеру к нам пришел новый с сервера какой-то user:
let user = {id: 100500, name: 'Igor'}
// таким вот образром мы присваиваем users нашего user, который пришел к нам.
users[user.id]=user; // моментальное добавление. Дубликатов не будет и все хорошо
// [user.id] превратится в строку '100500' и присвоится наш user.
// Т.е. получим '100500': {id: 100500, name: 'Igor'}
// !!!!!  Важно: Если у нас такой пользователь с таким же id уже был , то он у нас просто ПЕРЕЗАТРЁТСЯ

//---Удаление пользователя---
delete users[user.id] // моментальное удаление

//---Обновление пользователя---
users[user.id] = user // в таком варианте мы перезатрем полностью новым пользователем
users[user.id].name = 'Xenia' // в таком варианте мы обращаемся к пользователю .name и говорим, что теперь он не 'Igor' , а 'Xenia'







//------------------------------------ОБЫЧНЫЙ МАССИВ----------------------------------------------------------//
// ---Обычный массив. Удобен, когда мы знаем порядковые номера наших элементов, чтобы с ними можно было работать и как-то менять, изменять.
const usersArray = [
    {id: 101, name: 'Ivan'},
    {id: 326465, name: 'Lena'},
    {id: 586, name: 'Saha'},
    {id: 8988, name: 'Dima'},
    {id: 1, name: 'Xenia'},
]

//usersArray[4] // так достаем, очень долго О(n), и если мы точно знаем под каим номером наш искомый и нужный для нас элемент
// ---Доставание элемента из обычного массива:---
usersArray.find(u=>u.id === 1) // метод find(), также будет долго при каждой итерации искать нам нужный для наш элемент по id. Снова долго!!!

// ---Добавление в обычный массив, например при помощи push(). Если нам разрешается мутировать наш объект массив. Чтобы был новый.---
usersArray.push(user)
// !!! ВАЖНЫЙ МОМЕНТ: Если у нас такой user с таким же id уже был, то тут уже будет дублирование.

//Если нам нужно добваить нового пользователя, иммутабельно. То нам нужно сохранить старый массив и добваить в него нового:
let usersCopy = [...usersArray, user]
// !!!! НО ПРИ ЭТОМ ВАЖНО: Вдруг уже был такой user с id, поэтому желательно отфильтровать [...usersArray.filter(), user],
// а фильтрация означает пробегать по всем элементам.
// Получается снова возрастатет время от колличсетва элементов

//--- Удаление из обычного массива, снова при помощи filter по id нужной, а значит это снова время для пробегания нужно.
// filter пробегается по всем по всем... снова сложность операции от n - от количества элементов мы зависим. Долго
let usersDeleteArray = usersArray.filter(u=> u.id !== user.id) // fiter пропустит только те id  для которых это выражение " u.id !== user.id "  будет true